# UDP: 用户数据报协议 [RFC 768]
“无修饰”，“不加渲染的”因特网传输协议
“**尽力而为**”服务，UDP报文段可能： 
- **丢失**
- **会将失序的报文交付到应用程序**
**无连接：**
- 在UDP接收者、发送者之间没有握手
- 每个UDP 段的处理独立于其他段
**为什么要有 UDP?**
不需要建立连接 (减少延迟)
简单：在发送者接受者之间不需要连接状态
很小的报文段首部
没有拥塞控制：
- UDP 能够尽可能快地进行传递
- 可以在拥塞的情况下发挥作用
UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即**端口的功能和差错检测的功能**。
虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其特殊的优点。
- **UDP 是无连接的，即发送数据之前不需要建立连接。**
- **UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。UDP 没有拥塞控制，很适合多媒体通信的要求**（loss tolerant, rate sensitive）。 
- UDP 支持一对一、一对多、多对一和多对多的交互通信：流媒体、DNS、SNMP、HTTP/3。
**如果要在 UDP 上实现可靠传输（比如 HTTP/3）：**
- 在应用层增加可靠性
- 在应用层增加拥塞控制
UDP 的首部开销小，只有 8 个字节。
UDP 是面向报文的。
- 发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。
- 应用层交给 UDP 多长的报文，UDP 就照样发送，即**一次发送一个报文**。
- 接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，**一次交付一个完整的报文**。
- 应用程序必须选择合适大小的报文。
![image.png](https://picgo-1310230783.cos.ap-chengdu.myqcloud.com/obsidian/202303302026972.png)
# UDP：传输层动作
## UDP 发送方动作：
传递应用层消息
确定 UDP 段头部字段值
创建 UDP 报文段
传递报文段给 IP
## UDP 接收方动作
接收来自 IP 的数据报
检查 UDP 头部校验
提取应用层消息
通过套接字多路分解到应用程序
# UDP 首部格式 
![image.png](https://picgo-1310230783.cos.ap-chengdu.myqcloud.com/obsidian/202303302029044.png)
用户数据报 UDP 有两个字段：数据字段和首部字段。首部字段有 8 个字节，由 4 个字段组成，每个字段都是两个字节。长度是首部和数据的总长度，故最小值为8 。 
**UDP首部有8个字节，由4个字段构成，每个字段都是两个字节：**
1.源端口： 源端口号，需要对方回信时选用，不需要时全部置0.
2.目的端口：目的端口号，在终点交付报文的时候需要用到。
3.长度：UDP的数据报的长度（包括首部和数据）其最小值为8（只有首部）
4.[[03 无连接传输：UDP#UDP 校验和|校验和]]：检测UDP数据报在传输中是否有错，有错则丢弃。
- 该字段是可选的，当源主机不想计算校验和，则直接令该字段全为0.
当传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交给应用进程。
如果接收方UDP发现收到的报文中的目的端口号不正确（不存在对应端口号的应用进程），就丢弃该报文，并由ICMP发送“端口不可达”差错报文给对方。
# UDP 校验和
**目标: 对传输的报文段进行差错检测**
**发送方:**
- 将数据段看成16bit的整数序列
- 校验和：数据段内容相加 (1的补码和)
- 发送者将校验和值放入UDP的校验和域
**接收方:**
- 计算接收到数据段的校验和
- 检查计算的校验和是否等于校验和域中的值:
	- NO – 检测到错误
	- YES – 没有检测到错误
**但是可能是错误的**
# UDP 校验和与差错检测
![image.png](https://picgo-1310230783.cos.ap-chengdu.myqcloud.com/obsidian/202303302038363.png)
![image.png](https://picgo-1310230783.cos.ap-chengdu.myqcloud.com/obsidian/202303302040336.png)
![image.png](https://picgo-1310230783.cos.ap-chengdu.myqcloud.com/obsidian/202303302053053.png)
![image.png](https://picgo-1310230783.cos.ap-chengdu.myqcloud.com/obsidian/202303302053655.png)
**伪首部的作用：**
第一，通过伪首部的IP地址检验，UDP可以确认该数据报是不是发送给本机IP地址的；
第二，通过伪首部的协议字段检验，UDP可以确认IP有没有把不应该传给UDP而应该传给别的高层的数据报传给了UDP。
UDP的检验和所需要用到的所有信息，包括三个部分：
1. UDP伪首部
2. UDP首部
3. UDP的数据部分

首先解释下伪首部的概念，伪首部包含IP首部一些字段。其目的是让UDP两次检查数据是否已经正确到达目的地，只是单纯为了做校验用的。
还有一个概念十分重要，那就是16位UDP总长度，请注意该长度不是报文的总长度，而只是UDP（包括UDP头和数据部分）的总长度。

二、计算检验和（checksum）的过程很关键，主要分为以下几个步骤：
1. 把伪首部添加到UDP上
2. 计算初始时是需要将检验和字段添零的
3. 把所有位划分为16位（2字节）的字
4. 把所有16位的字相加，如果遇到进位，则将高于16字节的进位部分的值加到最低位上，举例，0xBB5E+0xFCED=0x1 B84B，则将1放到最低位，得到结果是0xB84C
5. 将所有字相加得到的结果应该为一个16位的数，将该数取反则可以得到检验和checksum。

伪首部的UDP长度=UDP数据包的UDP包长度字段值

伪首部包括了IPv4头部中的一些信息，但它并不是发送IP数据包时使用的IP数据包的头部，而只是一个用来计算校验和而已。接收主机在收到UDP报文以后，从IP首部获悉IP地址信息构造UDP伪首部。在进行校验和计算。

识别一个通信应用需要5个因素。"源IP地址"、"目标IP地址"、"源端口"、"目标端口"、"协议号"。UDP首部只包含了（源端口和目标端口），用此来校验，如果其他三项信息被破坏，极有可能导致应收包应用收不到，不应该收包的应用收到。
为此，有必要在通信中，验证这5项的识别码是否正确，就引入了伪首部的概念。
![image.png](https://picgo-1310230783.cos.ap-chengdu.myqcloud.com/obsidian/202303302058839.png)
在上图中，给出一个奇数长度的数据例子，因而在计算检验和时需要加上填充字节。**注意，UDP数据报的长度在检验和计算过程中出现两次。**
协议字段的值为**17(表示为UDP协议)**，UDP长度为UDP数据报的总长（不包括伪首部）。
如果检验和的计算结果为0，则存入的值为全1 (65535)，这在二进制反码计算中是等效的。如果传送的检验和为0，说明发送端没有计算检验和。如果发送端没有计算检验和而接收端检测到检验和有差错，那么UDP数据报就要被悄悄地丢弃, 不产生任何差错报文（当IP层检测到IP首部检验和有差错时也做同样处理）
>如：累加和为，11111111 11111111
则，校验和为，00000000 00000000 ->写入的是 111111111 11111111
在接收方，累加和 + 校验和 = 11111111 11111111，全1，表明传输正确。
![image.png](https://picgo-1310230783.cos.ap-chengdu.myqcloud.com/obsidian/202303302102108.png)
>这里最后一字节的数据 01000111 填充为 01000111 00000000，而非 00000000 01000111，是因为考虑网络字节序（大端），即0x1234，0x12是低位，0x34是高位。

UDP和TCP使用反码来计算它们的校验和。
假设有下面3个8比特字节：01010011,
                                       01100110,
                                       01110100。
1. 这些8比特字节的反码是多少？（注意：尽管UDP和TCP使用16比特的字来计算校验和，但对于这个问题，考虑的是8比特和。）写出计算过程。
			累加得到 0 0 1 0 1 1 1 0（注意，如果溢出，则回卷），其反码为 1 1 0 1 0 0 0 1。

2. UDP为什么要用该和的反码，即为什么不直接使用该和？
			为了检测错误，接收方可以直接累加四个字节（三个原始字节和校验和），简单方便高效。
3. 使用该反码方案，接收方如何检测出差错？1比特的差错能够被检测出来吗？2比特的差错呢？
			如果累加总和包含0，则接收方认为有错误。
			所有的1位错误都将被检测到，但是2位错误**可能**不被检测到（例如，如果第一个字节的最后一位变成了0，而第二个字节的最后一位变成1）。


一个UDP用户数据报的首部十六进制表示是：
                       06 32 00 45 00 1C E2 17
（1）试求源端口、目的端口、用户数据报的总长度、数据部分长度。
						源端口号（0632）目的端口号（0045）UDP报文段长度（001C）校验和（E217）
						源端口是0x0632 = 1586
						目的端口是0x0045 = 69
						UDP 用户数据报总长度是0x001C = 28
						数据部分长度是28-8 = 20。


（2）这个用户数据报是从客户发送给服务器还是服务器发送给客户？
						因为目的端口号69 < 1023，是[[02 多路复用和多路分解#^3d5c7b|熟知端口]]，所以此UDP用户数据报是从客户发给服务器。服务器程序实际就是TFTP。
# UDP小结
“没有多余的装饰”协议： 
- 报文段可能会丢失，无法按顺序交付
- 尽力而为服务：“send and hope for the best”
UDP 优点：
- 无需设置/握手（无RTT时延）
- 网络服务受到威胁时仍可工作 (can function when network service is compromised)
- 有一定的可靠性（校验和）
在应用层，在UDP之上可构建附加功能 (e.g., HTTP/3)
